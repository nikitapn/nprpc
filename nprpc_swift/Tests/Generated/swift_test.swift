// Generated by npidl compiler
// DO NOT EDIT - all changes will be lost

import NPRPC

public struct TestException: NPRPCError {
  public var __ex_id: UInt32
  public var message: String
  public var code: UInt32

  public init(__ex_id: UInt32, message: String, code: UInt32)   {
    self.__ex_id = __ex_id
    self.message = message
    self.code = code
  }

  public var message: String { "TestException" }
}

public struct Point: Codable, Sendable {
  public var x: Float
  public var y: Float

  public init(x: Float, y: Float)   {
    self.x = x
    self.y = y
  }
}


// MARK: - Marshal Point
public func marshal_Point(buffer: UnsafeMutableRawPointer, offset: Int, data: Point) {
  buffer.storeBytes(of: data.x, toByteOffset: offset + 0, as: Float.self)
  buffer.storeBytes(of: data.y, toByteOffset: offset + 4, as: Float.self)
}

// MARK: - Unmarshal Point
public func unmarshal_Point(buffer: UnsafeRawPointer, offset: Int) -> Point {
  var result = Point()
  result.x = buffer.load(fromByteOffset: offset + 0, as: Float.self)
  result.y = buffer.load(fromByteOffset: offset + 4, as: Float.self)
  return result
}

public struct Rectangle: Codable, Sendable {
  public var top_left: Point
  public var width: Float
  public var height: Float

  public init(top_left: Point, width: Float, height: Float)   {
    self.top_left = top_left
    self.width = width
    self.height = height
  }
}


// MARK: - Marshal Rectangle
public func marshal_Rectangle(buffer: UnsafeMutableRawPointer, offset: Int, data: Rectangle) {
  marshal_Point(buffer: buffer, offset: offset + 0, data: data.top_left)
  buffer.storeBytes(of: data.width, toByteOffset: offset + 8, as: Float.self)
  buffer.storeBytes(of: data.height, toByteOffset: offset + 12, as: Float.self)
}

// MARK: - Unmarshal Rectangle
public func unmarshal_Rectangle(buffer: UnsafeRawPointer, offset: Int) -> Rectangle {
  var result = Rectangle()
  result.top_left = unmarshal_Point(buffer: buffer, offset: offset + 0)
  result.width = buffer.load(fromByteOffset: offset + 8, as: Float.self)
  result.height = buffer.load(fromByteOffset: offset + 12, as: Float.self)
  return result
}

public protocol CalculatorProtocol {
  func add(a: UInt32, b: UInt32) throws -> UInt32
  func multiply(a: UInt32, b: UInt32) throws -> UInt32
  func divide(numerator: UInt32, denominator: UInt32) throws -> Float
}

// Client proxy for Calculator
// Pure Swift implementation with direct marshalling
public class Calculator: CalculatorProtocol {
  private let object: NPRPCObject

  public init(_ object: NPRPCObject)   {
    self.object = object
  }

  public func add(a: UInt32, b: UInt32) throws -> UInt32   {
    // Prepare buffer
    let buffer = FlatBuffer()
    buffer.prepare(40)
    buffer.commit(40)
    guard let data = buffer.data else { throw NPRPCError.bufferError }

    // Write message header
    data.storeBytes(of: UInt32(0), toByteOffset: 0, as: UInt32.self)  // size (set later)
    data.storeBytes(of: UInt32(1), toByteOffset: 4, as: UInt32.self)  // msg_id: FunctionCall
    data.storeBytes(of: UInt32(0), toByteOffset: 8, as: UInt32.self)  // msg_type: Request
    data.storeBytes(of: UInt32(0), toByteOffset: 12, as: UInt32.self) // reserved

    // Write call header
    data.storeBytes(of: object.poaIdx, toByteOffset: 16, as: UInt16.self)
    data.storeBytes(of: UInt8(0), toByteOffset: 18, as: UInt8.self)  // interface_idx
    data.storeBytes(of: UInt8(0), toByteOffset: 19, as: UInt8.self)  // function_idx
    data.storeBytes(of: object.objectId, toByteOffset: 24, as: UInt64.self)

    // Marshal input arguments
    let inArgs = (_1: a, _2: b)
    marshal_basic_test_M1(buffer: data, offset: 32, data: inArgs)

    data.storeBytes(of: UInt32(36), toByteOffset: 0, as: UInt32.self)

    // Send and receive
    try object.session.sendReceive(buffer: buffer, timeout: object.timeout)

    // Handle reply
    let stdReply = handleStandardReply(buffer: buffer)
    if stdReply != -1 { throw NPRPCError.unexpectedReply }

    guard let responseData = buffer.data else { throw NPRPCError.bufferError }
    let out = unmarshal_basic_test_M2(buffer: responseData, offset: 16)
    return out._1
  }

  public func multiply(a: UInt32, b: UInt32) throws -> UInt32   {
    // Prepare buffer
    let buffer = FlatBuffer()
    buffer.prepare(40)
    buffer.commit(40)
    guard let data = buffer.data else { throw NPRPCError.bufferError }

    // Write message header
    data.storeBytes(of: UInt32(0), toByteOffset: 0, as: UInt32.self)  // size (set later)
    data.storeBytes(of: UInt32(1), toByteOffset: 4, as: UInt32.self)  // msg_id: FunctionCall
    data.storeBytes(of: UInt32(0), toByteOffset: 8, as: UInt32.self)  // msg_type: Request
    data.storeBytes(of: UInt32(0), toByteOffset: 12, as: UInt32.self) // reserved

    // Write call header
    data.storeBytes(of: object.poaIdx, toByteOffset: 16, as: UInt16.self)
    data.storeBytes(of: UInt8(0), toByteOffset: 18, as: UInt8.self)  // interface_idx
    data.storeBytes(of: UInt8(1), toByteOffset: 19, as: UInt8.self)  // function_idx
    data.storeBytes(of: object.objectId, toByteOffset: 24, as: UInt64.self)

    // Marshal input arguments
    let inArgs = (_1: a, _2: b)
    marshal_basic_test_M1(buffer: data, offset: 32, data: inArgs)

    data.storeBytes(of: UInt32(36), toByteOffset: 0, as: UInt32.self)

    // Send and receive
    try object.session.sendReceive(buffer: buffer, timeout: object.timeout)

    // Handle reply
    let stdReply = handleStandardReply(buffer: buffer)
    if stdReply != -1 { throw NPRPCError.unexpectedReply }

    guard let responseData = buffer.data else { throw NPRPCError.bufferError }
    let out = unmarshal_basic_test_M2(buffer: responseData, offset: 16)
    return out._1
  }

  public func divide(numerator: UInt32, denominator: UInt32) throws -> Float   {
    // Prepare buffer
    let buffer = FlatBuffer()
    buffer.prepare(40)
    buffer.commit(40)
    guard let data = buffer.data else { throw NPRPCError.bufferError }

    // Write message header
    data.storeBytes(of: UInt32(0), toByteOffset: 0, as: UInt32.self)  // size (set later)
    data.storeBytes(of: UInt32(1), toByteOffset: 4, as: UInt32.self)  // msg_id: FunctionCall
    data.storeBytes(of: UInt32(0), toByteOffset: 8, as: UInt32.self)  // msg_type: Request
    data.storeBytes(of: UInt32(0), toByteOffset: 12, as: UInt32.self) // reserved

    // Write call header
    data.storeBytes(of: object.poaIdx, toByteOffset: 16, as: UInt16.self)
    data.storeBytes(of: UInt8(0), toByteOffset: 18, as: UInt8.self)  // interface_idx
    data.storeBytes(of: UInt8(2), toByteOffset: 19, as: UInt8.self)  // function_idx
    data.storeBytes(of: object.objectId, toByteOffset: 24, as: UInt64.self)

    // Marshal input arguments
    let inArgs = (_1: numerator, _2: denominator)
    marshal_basic_test_M1(buffer: data, offset: 32, data: inArgs)

    data.storeBytes(of: UInt32(36), toByteOffset: 0, as: UInt32.self)

    // Send and receive
    try object.session.sendReceive(buffer: buffer, timeout: object.timeout)

    // Handle reply
    let stdReply = handleStandardReply(buffer: buffer)
    if stdReply == 1 { throw basic_test_throwException(buffer: buffer) }
    if stdReply != -1 { throw NPRPCError.unexpectedReply }

    guard let responseData = buffer.data else { throw NPRPCError.bufferError }
    let out = unmarshal_basic_test_M3(buffer: responseData, offset: 16)
    return out._1
  }

}

// Servant base for Calculator
open class CalculatorServant: NPRPCServant, CalculatorProtocol {
  public override init() { super.init() }

  open func add(a: UInt32, b: UInt32) throws -> UInt32   {
    fatalError("Subclass must implement add")
  }

  open func multiply(a: UInt32, b: UInt32) throws -> UInt32   {
    fatalError("Subclass must implement multiply")
  }

  open func divide(numerator: UInt32, denominator: UInt32) throws -> Float   {
    fatalError("Subclass must implement divide")
  }

  // Dispatch incoming RPC calls
  public override func dispatch(buffer: FlatBuffer, remoteEndpoint: NPRPCEndpoint)   {
    guard let data = buffer.data else { return }

    // Read function index
    let functionIdx = data.load(fromByteOffset: 19, as: UInt8.self)

    switch functionIdx     {
      case 0: // Add
      {
        
// Unmarshal input arguments
        let ia = unmarshal_basic_test_M1(buffer: data, offset: 32)
        
        let __ret_val = try add(a: ia._1, b: ia._2)
        
// Prepare output buffer
        let obuf = buffer
        obuf.consume(obuf.size)
        obuf.prepare(20)
        obuf.commit(20)
        
// Marshal output arguments
        guard let outData = buffer.data else { return }
        let out_data = (_1: __ret_val)
        marshal_basic_test_M2(buffer: outData, offset: 16, data: out_data)
        outData.storeBytes(of: UInt32(buffer.size - 4), toByteOffset: 0, as: UInt32.self)
        outData.storeBytes(of: UInt32(2), toByteOffset: 4, as: UInt32.self)  // MessageId.BlockResponse
        outData.storeBytes(of: UInt32(1), toByteOffset: 8, as: UInt32.self)  // MessageType.Answer
      }
      case 1: // Multiply
      {
        
// Unmarshal input arguments
        let ia = unmarshal_basic_test_M1(buffer: data, offset: 32)
        
        let __ret_val = try multiply(a: ia._1, b: ia._2)
        
// Prepare output buffer
        let obuf = buffer
        obuf.consume(obuf.size)
        obuf.prepare(20)
        obuf.commit(20)
        
// Marshal output arguments
        guard let outData = buffer.data else { return }
        let out_data = (_1: __ret_val)
        marshal_basic_test_M2(buffer: outData, offset: 16, data: out_data)
        outData.storeBytes(of: UInt32(buffer.size - 4), toByteOffset: 0, as: UInt32.self)
        outData.storeBytes(of: UInt32(2), toByteOffset: 4, as: UInt32.self)  // MessageId.BlockResponse
        outData.storeBytes(of: UInt32(1), toByteOffset: 8, as: UInt32.self)  // MessageType.Answer
      }
      case 2: // Divide
      {
        
// Unmarshal input arguments
        let ia = unmarshal_basic_test_M1(buffer: data, offset: 32)
        
        do         {
          let _out_result = try divide(numerator: ia._1, denominator: ia._2)
        }
        catch let e as TestException         {
          let obuf = buffer
          obuf.consume(obuf.size)
          obuf.prepare(32)
          obuf.commit(32)
          guard let exData = obuf.data else { return }
          let ex_data = (__ex_id: 0, message: e.message, code: e.code)
          marshal_TestException(buffer: exData, offset: 16, data: ex_data)
          exData.storeBytes(of: UInt32(obuf.size - 4), toByteOffset: 0, as: UInt32.self)
          exData.storeBytes(of: UInt32(3), toByteOffset: 4, as: UInt32.self)  // MessageId.Exception
          exData.storeBytes(of: UInt32(1), toByteOffset: 8, as: UInt32.self)  // MessageType.Answer
          return
        }
        catch         {
          makeSimpleAnswer(buffer: buffer, messageId: 10)  // Error
          return
        }
        
// Prepare output buffer
        let obuf = buffer
        obuf.consume(obuf.size)
        obuf.prepare(20)
        obuf.commit(20)
        
// Marshal output arguments
        guard let outData = buffer.data else { return }
        let out_data = (_1: _out_result)
        marshal_basic_test_M3(buffer: outData, offset: 16, data: out_data)
        outData.storeBytes(of: UInt32(buffer.size - 4), toByteOffset: 0, as: UInt32.self)
        outData.storeBytes(of: UInt32(2), toByteOffset: 4, as: UInt32.self)  // MessageId.BlockResponse
        outData.storeBytes(of: UInt32(1), toByteOffset: 8, as: UInt32.self)  // MessageType.Answer
      }
      default:
      {
        makeSimpleAnswer(buffer: buffer, messageId: 10)  // Error_UnknownFunctionIdx
      }
    }
 // switch
  }
 // dispatch
}

public protocol GeometryProtocol {
  func calculateArea(rect: Rectangle) throws -> Float
  func getBounds(rect: Rectangle) throws -> (Float, Float)
}

// Client proxy for Geometry
// Pure Swift implementation with direct marshalling
public class Geometry: GeometryProtocol {
  private let object: NPRPCObject

  public init(_ object: NPRPCObject)   {
    self.object = object
  }

  public func calculateArea(rect: Rectangle) throws -> Float   {
    // Prepare buffer
    let buffer = FlatBuffer()
    buffer.prepare(48)
    buffer.commit(48)
    guard let data = buffer.data else { throw NPRPCError.bufferError }

    // Write message header
    data.storeBytes(of: UInt32(0), toByteOffset: 0, as: UInt32.self)  // size (set later)
    data.storeBytes(of: UInt32(1), toByteOffset: 4, as: UInt32.self)  // msg_id: FunctionCall
    data.storeBytes(of: UInt32(0), toByteOffset: 8, as: UInt32.self)  // msg_type: Request
    data.storeBytes(of: UInt32(0), toByteOffset: 12, as: UInt32.self) // reserved

    // Write call header
    data.storeBytes(of: object.poaIdx, toByteOffset: 16, as: UInt16.self)
    data.storeBytes(of: UInt8(0), toByteOffset: 18, as: UInt8.self)  // interface_idx
    data.storeBytes(of: UInt8(0), toByteOffset: 19, as: UInt8.self)  // function_idx
    data.storeBytes(of: object.objectId, toByteOffset: 24, as: UInt64.self)

    // Marshal input arguments
    let inArgs = (_1: rect)
    marshal_basic_test_M4(buffer: data, offset: 32, data: inArgs)

    data.storeBytes(of: UInt32(44), toByteOffset: 0, as: UInt32.self)

    // Send and receive
    try object.session.sendReceive(buffer: buffer, timeout: object.timeout)

    // Handle reply
    let stdReply = handleStandardReply(buffer: buffer)
    if stdReply != -1 { throw NPRPCError.unexpectedReply }

    guard let responseData = buffer.data else { throw NPRPCError.bufferError }
    let out = unmarshal_basic_test_M3(buffer: responseData, offset: 16)
    return out._1
  }

  public func getBounds(rect: Rectangle) throws -> (Float, Float)   {
    // Prepare buffer
    let buffer = FlatBuffer()
    buffer.prepare(48)
    buffer.commit(48)
    guard let data = buffer.data else { throw NPRPCError.bufferError }

    // Write message header
    data.storeBytes(of: UInt32(0), toByteOffset: 0, as: UInt32.self)  // size (set later)
    data.storeBytes(of: UInt32(1), toByteOffset: 4, as: UInt32.self)  // msg_id: FunctionCall
    data.storeBytes(of: UInt32(0), toByteOffset: 8, as: UInt32.self)  // msg_type: Request
    data.storeBytes(of: UInt32(0), toByteOffset: 12, as: UInt32.self) // reserved

    // Write call header
    data.storeBytes(of: object.poaIdx, toByteOffset: 16, as: UInt16.self)
    data.storeBytes(of: UInt8(0), toByteOffset: 18, as: UInt8.self)  // interface_idx
    data.storeBytes(of: UInt8(1), toByteOffset: 19, as: UInt8.self)  // function_idx
    data.storeBytes(of: object.objectId, toByteOffset: 24, as: UInt64.self)

    // Marshal input arguments
    let inArgs = (_1: rect)
    marshal_basic_test_M4(buffer: data, offset: 32, data: inArgs)

    data.storeBytes(of: UInt32(44), toByteOffset: 0, as: UInt32.self)

    // Send and receive
    try object.session.sendReceive(buffer: buffer, timeout: object.timeout)

    // Handle reply
    let stdReply = handleStandardReply(buffer: buffer)
    if stdReply != -1 { throw NPRPCError.unexpectedReply }

    guard let responseData = buffer.data else { throw NPRPCError.bufferError }
    let out = unmarshal_basic_test_M5(buffer: responseData, offset: 16)
    return (out._1, out._2)
  }

}

// Servant base for Geometry
open class GeometryServant: NPRPCServant, GeometryProtocol {
  public override init() { super.init() }

  open func calculateArea(rect: Rectangle) throws -> Float   {
    fatalError("Subclass must implement calculateArea")
  }

  open func getBounds(rect: Rectangle) throws -> (Float, Float)   {
    fatalError("Subclass must implement getBounds")
  }

  // Dispatch incoming RPC calls
  public override func dispatch(buffer: FlatBuffer, remoteEndpoint: NPRPCEndpoint)   {
    guard let data = buffer.data else { return }

    // Read function index
    let functionIdx = data.load(fromByteOffset: 19, as: UInt8.self)

    switch functionIdx     {
      case 0: // CalculateArea
      {
        
// Unmarshal input arguments
        let ia = unmarshal_basic_test_M4(buffer: data, offset: 32)
        
        let __ret_val = try calculateArea(rect: ia._1)
        
// Prepare output buffer
        let obuf = buffer
        obuf.consume(obuf.size)
        obuf.prepare(20)
        obuf.commit(20)
        
// Marshal output arguments
        guard let outData = buffer.data else { return }
        let out_data = (_1: __ret_val)
        marshal_basic_test_M3(buffer: outData, offset: 16, data: out_data)
        outData.storeBytes(of: UInt32(buffer.size - 4), toByteOffset: 0, as: UInt32.self)
        outData.storeBytes(of: UInt32(2), toByteOffset: 4, as: UInt32.self)  // MessageId.BlockResponse
        outData.storeBytes(of: UInt32(1), toByteOffset: 8, as: UInt32.self)  // MessageType.Answer
      }
      case 1: // GetBounds
      {
        
// Unmarshal input arguments
        let ia = unmarshal_basic_test_M4(buffer: data, offset: 32)
        
        let (_out_area, _out_perimeter) = try getBounds(rect: ia._1)
        
// Prepare output buffer
        let obuf = buffer
        obuf.consume(obuf.size)
        obuf.prepare(24)
        obuf.commit(24)
        
// Marshal output arguments
        guard let outData = buffer.data else { return }
        let out_data = (_1: _out_area, _2: _out_perimeter)
        marshal_basic_test_M5(buffer: outData, offset: 16, data: out_data)
        outData.storeBytes(of: UInt32(buffer.size - 4), toByteOffset: 0, as: UInt32.self)
        outData.storeBytes(of: UInt32(2), toByteOffset: 4, as: UInt32.self)  // MessageId.BlockResponse
        outData.storeBytes(of: UInt32(1), toByteOffset: 8, as: UInt32.self)  // MessageType.Answer
      }
      default:
      {
        makeSimpleAnswer(buffer: buffer, messageId: 10)  // Error_UnknownFunctionIdx
      }
    }
 // switch
  }
 // dispatch
}

