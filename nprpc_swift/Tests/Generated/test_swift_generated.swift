// Copyright (c) 2021-2025, Nikita Penkie <nikitapnn1@gmail.com>
// SPDX-License-Identifier: MIT

// GENERATED CODE - Swift marshalling for test_swift.npidl
// This is generated by npidl --swift and has NO dependency on C++ generated stubs

import CNprpc

// ============================================================================
// Generated Structures
// ============================================================================

public enum Color: UInt32 {
    case red = 0
    case green = 1
    case blue = 2
}

public struct Point {
    public var x: Int32
    public var y: Int32
    
    public init(x: Int32, y: Int32) {
        self.x = x
        self.y = y
    }
}

public struct Rectangle {
    public var topLeft: Point
    public var bottomRight: Point
    public var color: Color
    
    public init(topLeft: Point, bottomRight: Point, color: Color) {
        self.topLeft = topLeft
        self.bottomRight = bottomRight
        self.color = color
    }
}

// ============================================================================
// Marshalling helpers (generated)
// ============================================================================

extension Point {
    // Marshal into flat buffer at offset
    func marshal(to buffer: UnsafeMutableRawPointer, offset: Int) {
        buffer.storeBytes(of: x, toByteOffset: offset, as: Int32.self)
        buffer.storeBytes(of: y, toByteOffset: offset + 4, as: Int32.self)
    }
    
    // Unmarshal from flat buffer at offset
    static func unmarshal(from buffer: UnsafeRawPointer, offset: Int) -> Point {
        let x = buffer.load(fromByteOffset: offset, as: Int32.self)
        let y = buffer.load(fromByteOffset: offset + 4, as: Int32.self)
        return Point(x: x, y: y)
    }
}

extension Rectangle {
    func marshal(to buffer: UnsafeMutableRawPointer, offset: Int) {
        topLeft.marshal(to: buffer, offset: offset + 0)
        bottomRight.marshal(to: buffer, offset: offset + 8)
        buffer.storeBytes(of: color.rawValue, toByteOffset: offset + 16, as: UInt32.self)
    }
    
    static func unmarshal(from buffer: UnsafeRawPointer, offset: Int) -> Rectangle {
        let topLeft = Point.unmarshal(from: buffer, offset: offset + 0)
        let bottomRight = Point.unmarshal(from: buffer, offset: offset + 8)
        let colorRaw = buffer.load(fromByteOffset: offset + 16, as: UInt32.self)
        let color = Color(rawValue: colorRaw) ?? .red
        return Rectangle(topLeft: topLeft, bottomRight: bottomRight, color: color)
    }
}

// ============================================================================
// Calculator Client (generated)
// ============================================================================

public class Calculator {
    private let object: UnsafeMutablePointer<nprpc_swift.Object>
    
    internal init(object: UnsafeMutablePointer<nprpc_swift.Object>) {
        self.object = object
    }
    
    public func add(a: Int32, b: Int32) throws -> Int32 {
        // Allocate buffer
        guard let buf = nprpc_swift.FlatBuffer_create() else {
            throw RuntimeError(message: "Failed to create buffer")
        }
        defer { nprpc_swift.FlatBuffer_destroy(buf) }
        
        // Get session
        guard let session = nprpc_swift.Session_get(object) else {
            throw RuntimeError(message: "Failed to get session")
        }
        
        // Prepare buffer (Header=16, CallHeader=16, Args=8)
        let bufSize = 40
        nprpc_swift.FlatBuffer_prepare(buf, bufSize)
        nprpc_swift.FlatBuffer_commit(buf, bufSize)
        
        guard let data = nprpc_swift.FlatBuffer_data(buf) else {
            throw RuntimeError(message: "Failed to get buffer data")
        }
        
        // Write message header
        data.storeBytes(of: UInt32(0), toByteOffset: 0, as: UInt32.self)  // size (filled later)
        data.storeBytes(of: UInt32(1), toByteOffset: 4, as: UInt32.self)  // msg_id: FunctionCall
        data.storeBytes(of: UInt32(0), toByteOffset: 8, as: UInt32.self)  // msg_type: Request
        data.storeBytes(of: UInt32(0), toByteOffset: 12, as: UInt32.self) // reserved
        
        // Write call header
        let objectId = nprpc_swift.Object_get_id(object)
        let poaIdx = nprpc_swift.Object_get_poa_idx(object)
        data.storeBytes(of: objectId, toByteOffset: 16, as: UInt32.self)   // object_id
        data.storeBytes(of: poaIdx, toByteOffset: 20, as: UInt8.self)       // poa_idx
        data.storeBytes(of: UInt8(0), toByteOffset: 21, as: UInt8.self)     // interface_idx
        data.storeBytes(of: UInt16(0), toByteOffset: 22, as: UInt16.self)   // function_idx (add = 0)
        data.storeBytes(of: UInt64(0), toByteOffset: 24, as: UInt64.self)   // reserved
        
        // Marshal arguments (offset 32)
        data.storeBytes(of: a, toByteOffset: 32, as: Int32.self)
        data.storeBytes(of: b, toByteOffset: 36, as: Int32.self)
        
        // Set message size
        data.storeBytes(of: UInt32(bufSize - 4), toByteOffset: 0, as: UInt32.self)
        
        // Send/receive
        let timeout = nprpc_swift.Object_get_timeout(object)
        nprpc_swift.Session_send_receive(session, buf, timeout)
        
        // Check for standard reply
        let stdReply = nprpc_swift.handle_standard_reply(buf)
        if stdReply != -1 {
            throw RuntimeError(message: "RPC error: \(stdReply)")
        }
        
        // Unmarshal result (offset 16)
        guard let resultData = nprpc_swift.FlatBuffer_data(buf) else {
            throw RuntimeError(message: "No response data")
        }
        let result = resultData.load(fromByteOffset: 16, as: Int32.self)
        return result
    }
    
    public func divide(numerator: Double, denominator: Double) throws -> Double {
        // Similar pattern... (buffer size = 48)
        // This would be generated by npidl
        fatalError("Not yet implemented - generated code would go here")
    }
}

// ============================================================================
// Calculator Servant (generated protocol)
// ============================================================================

public protocol CalculatorServant: AnyObject {
    func add(a: Int32, b: Int32) -> Int32
    func divide(numerator: Double, denominator: Double) -> Double
}

// Swift servant wrapper for C++ bridging
class CalculatorServantBridge {
    weak var servant: CalculatorServant?
    
    init(servant: CalculatorServant) {
        self.servant = servant
    }
    
    // Dispatch function called from C++ when RPC arrives
    func dispatch(sessionCtx: UnsafeMutableRawPointer) {
        guard let servant = servant else { return }
        
        // Get buffers from session context
        guard let rxBuf = nprpc_swift.SessionContext_get_rx_buffer(sessionCtx),
              let txBuf = nprpc_swift.SessionContext_get_tx_buffer(sessionCtx),
              let rxData = nprpc_swift.FlatBuffer_data(rxBuf) else {
            return
        }
        
        // Read call header
        let functionIdx = rxData.load(fromByteOffset: 22, as: UInt16.self)
        
        switch functionIdx {
        case 0:  // add
            // Read arguments (offset 32)
            let a = rxData.load(fromByteOffset: 32, as: Int32.self)
            let b = rxData.load(fromByteOffset: 36, as: Int32.self)
            
            // Call servant
            let result = servant.add(a: a, b: b)
            
            // Prepare response buffer
            nprpc_swift.FlatBuffer_consume(txBuf, nprpc_swift.FlatBuffer_size(txBuf))
            nprpc_swift.FlatBuffer_prepare(txBuf, 20)
            nprpc_swift.FlatBuffer_commit(txBuf, 20)
            
            guard let txData = nprpc_swift.FlatBuffer_data(txBuf) else { return }
            
            // Write response header
            txData.storeBytes(of: UInt32(16), toByteOffset: 0, as: UInt32.self)  // size
            txData.storeBytes(of: UInt32(2), toByteOffset: 4, as: UInt32.self)   // msg_id: BlockResponse
            txData.storeBytes(of: UInt32(1), toByteOffset: 8, as: UInt32.self)   // msg_type: Answer
            
            // Write result (offset 16)
            txData.storeBytes(of: result, toByteOffset: 16, as: Int32.self)
            
        case 1:  // divide
            // Similar pattern...
            break
            
        default:
            nprpc_swift.SessionContext_make_simple_answer(sessionCtx, 10)  // Error_UnknownFunctionIdx
        }
    }
}

// ============================================================================
// POA Extension for activating Swift servants
// ============================================================================

extension Poa {
    public func activateCalculator(_ servant: CalculatorServant) throws -> Calculator {
        let bridge = CalculatorServantBridge(servant: servant)
        
        // Create opaque pointer to Swift object
        let swiftPtr = Unmanaged.passRetained(bridge).toOpaque()
        
        // Dispatch trampoline (C function pointer)
        let dispatchFn: @convention(c) (UnsafeMutableRawPointer?, UnsafeMutableRawPointer?) -> Void = { swiftServant, sessionCtx in
            guard let swiftServant = swiftServant, let sessionCtx = sessionCtx else { return }
            let bridge = Unmanaged<CalculatorServantBridge>.fromOpaque(swiftServant).takeUnretainedValue()
            bridge.dispatch(sessionCtx: sessionCtx)
        }
        
        // Activate in C++ POA
        guard let objectPtr = nprpc_swift.Poa_activate_servant(
            self.handle,
            swiftPtr,
            "test_swift/Calculator",
            dispatchFn
        ) else {
            Unmanaged<CalculatorServantBridge>.fromOpaque(swiftPtr).release()
            throw RuntimeError(message: "Failed to activate servant")
        }
        
        return Calculator(object: objectPtr)
    }
}
