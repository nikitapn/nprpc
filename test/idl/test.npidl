// Copyright (c) 2022 nikitapnn1@gmail.com
// This file is a part of npsystem (Distributed Control System) and covered by LICENSING file in the topmost directory

namespace test {
using Id = u32;
using IdArray = vector<Id>;
using bytestream = vector<u8>;

AssertionFailed : exception {
	message: string;
}

interface ServerControl {
	// All tests performed, safe to shutdown the server
	void Shutdown();
}

[force_helpers=1]
FlatStruct : flat {
	a: i32;
	b: u32;
	c: float32;
}

[force_helpers=1]
AAA: flat {
	a: u32;
	b: string;
	c: string;
}

[force_helpers=1]
SimpleStruct : flat {
	id: u32;
}

SimpleException : exception {
	message: string;
	code: u32;
}

interface TestBasic {
	boolean ReturnBoolean() raises (AssertionFailed);
	IdArray ReturnIdArray() raises (AssertionFailed);
	u32 ReturnU32() raises (AssertionFailed);

	boolean In(a: in u32, b: in boolean, c: in vector<u8>) raises (AssertionFailed);
	void Out(a: out u32, b: out boolean, c: out vector<u8>) raises (AssertionFailed);

	void OutStruct(a: out AAA) raises (AssertionFailed);
	void OutArrayOfStructs(a: out vector<SimpleStruct>) raises (AssertionFailed);

	void InException() raises (SimpleException);
	
	// Test case for flat output struct with simple scalar out parameter and exception handler
	// This tests the fix for variable scope when output params are declared before try block
	void OutScalarWithException(dev_addr: in u8, addr: in u16, value: out u8) raises (SimpleException);
}

interface TestLargeMessage {
	boolean In(a: in u32, b: in boolean, c: in vector<u8>);
	void Out(a: out u32, b: out boolean, c: out vector<u8>);
}

[force_helpers=1]
Opt1 : flat {
	str: string;
	stream?: bytestream;
};

interface TestOptional {
	boolean InEmpty(a?: in u32) raises (AssertionFailed);
	boolean In(a?: in u32, b?: in AAA) raises (AssertionFailed);
//	boolean InVec(a?: in bytestream);

	void OutEmpty(a?: out u32) raises (AssertionFailed);
	void Out(a?: out u32) raises (AssertionFailed);

	Opt1 ReturnOpt1() raises (AssertionFailed);
}

interface SimpleObject {
	async SetValue(a: in u32);
}

NestedObjects : flat {
	object1: /* SimpleObject */ object;
	object2: /* SimpleObject */ object;
}

interface TestObjects {
	void SendObject(o: in /* SimpleObject */ object) raises (AssertionFailed);
	void ReleaseReceivedObject() raises (AssertionFailed);

	void SendNestedObjects(o: in NestedObjects) raises (AssertionFailed);
}

[force_helpers=1]
CCC : flat {
	a: string;
	b: string;
	c?: boolean;
}

[force_helpers=1]
BBB : flat {
	a: vector<AAA>;
	b: vector<CCC>;
}

[force_helpers=1]
Level2 : flat {
	x: string;
	y: vector<u8>;
	z: u64;
}

[force_helpers=1]
Level1 : flat {
	x: string;
	y: Level2;
	z: u64;
}

[force_helpers=1]
TopLevel : flat {
	x: string;
	y: Level1;
	z: u64;
}

interface TestNested {
	void Out(a?: out BBB) raises (AssertionFailed);
	TopLevel ReturnNested() raises (AssertionFailed);
}

[trusted=false]
interface TestBadInput {
	void In(a: in vector<u8>);
}

}