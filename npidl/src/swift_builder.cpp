// Copyright (c) 2021-2025, Nikita Pennie <nikitapnn1@gmail.com>
// SPDX-License-Identifier: MIT

#include "swift_builder.hpp"
#include <cassert>
#include <iostream>

namespace npidl::builders {

namespace {
bool is_integral(TokenId id)
{
  return id == TokenId::Int8 || id == TokenId::UInt8 ||
         id == TokenId::Int16 || id == TokenId::UInt16 ||
         id == TokenId::Int32 || id == TokenId::UInt32 ||
         id == TokenId::Int64 || id == TokenId::UInt64;
}

bool is_floating_point(TokenId id)
{
  return id == TokenId::Float32 || id == TokenId::Float64;
}
} // anonymous namespace

SwiftBuilder::SwiftBuilder(Context* ctx, std::filesystem::path out_dir)
    : Builder(ctx)
    , out_dir_(std::move(out_dir))
{
  // Swift file header
  out << "// Generated by npidl compiler\n";
  out << "// DO NOT EDIT - all changes will be lost\n\n";
  out << "import NPRPC\n\n";
}

std::ostream& operator<<(std::ostream& os, const SwiftBuilder::_ns& ns)
{
  if (!ns.nm->name().empty()) {
    // Swift uses nested enums for namespaces
    os << ns.nm->name();
  }
  return os;
}

SwiftBuilder::_ns SwiftBuilder::ns(Namespace* nm) const
{
  return {*this, nm};
}

std::string SwiftBuilder::swift_type_name(const std::string& name) const
{
  // Convert C++ naming to Swift (PascalCase)
  // Already assumes PascalCase from IDL
  return name;
}

std::string SwiftBuilder::swift_method_name(const std::string& name) const
{
  // Convert to camelCase for Swift methods
  if (name.empty())
    return name;
  std::string result = name;
  result[0] = std::tolower(result[0]);
  return result;
}

void SwiftBuilder::emit_fundamental_type(TokenId id, std::ostream& os)
{
  switch (id) {
  case TokenId::Boolean:
    os << "Bool";
    break;
  case TokenId::Int8:
    os << "Int8";
    break;
  case TokenId::UInt8:
    os << "UInt8";
    break;
  case TokenId::Int16:
    os << "Int16";
    break;
  case TokenId::UInt16:
    os << "UInt16";
    break;
  case TokenId::Int32:
    os << "Int32";
    break;
  case TokenId::UInt32:
    os << "UInt32";
    break;
  case TokenId::Int64:
    os << "Int64";
    break;
  case TokenId::UInt64:
    os << "UInt64";
    break;
  case TokenId::Float32:
    os << "Float";
    break;
  case TokenId::Float64:
    os << "Double";
    break;
  default:
    assert(false && "Unknown fundamental type");
  }
}

void SwiftBuilder::emit_type(AstTypeDecl* type, std::ostream& os)
{
  switch (type->id) {
  case FieldType::Fundamental:
    emit_fundamental_type(cft(type)->token_id, os);
    break;
  case FieldType::Struct:
    // In Swift, don't prefix with namespace if it's in the same module
    os << swift_type_name(cflat(type)->name);
    break;
  case FieldType::Vector:
  case FieldType::Array:
    os << "[";
    emit_type(cwt(type)->type, os);
    os << "]";
    break;
  case FieldType::String:
    os << "String";
    break;
  case FieldType::Void:
    // Swift uses Void or ()
    os << "Void";
    break;
  case FieldType::Object:
    os << "ObjectPtr<Object>";
    break;
  case FieldType::Alias:
    // In Swift, don't prefix with namespace if it's in the same module
    os << swift_type_name(calias(type)->name);
    break;
  case FieldType::Enum:
    // In Swift, don't prefix with namespace if it's in the same module
    os << swift_type_name(cenum(type)->name);
    break;
  case FieldType::Optional:
    emit_type(cwt(type)->type, os);
    os << "?";
    break;
  default:
    assert(false && "Unknown type");
  }
}

void SwiftBuilder::emit_constant(const std::string& name, AstNumber* number)
{
  out << bl() << "public let " << name << ": ";
  
  if (number->is_decimal()) {
    auto val = number->decimal();
    if (val < 0) {
      out << "Int = " << val;
    } else {
      out << "UInt = " << val;
    }
  } else {
    out << "Double = " << *number;
  }
  
  out << "\n\n";
}

void SwiftBuilder::emit_field(AstFieldDecl* f, std::ostream& os)
{
  os << bl() << "public var " << f->name << ": ";
  emit_type(f->type, os);
  
  // Swift requires default values or optionals
  switch (f->type->id) {
  case FieldType::Optional:
    os << " = nil";
    break;
  case FieldType::String:
    os << " = \"\"";
    break;
  case FieldType::Array:
  case FieldType::Vector:
    os << " = []";
    break;
  case FieldType::Fundamental: {
    auto token_id = cft(f->type)->token_id;
    if (token_id == TokenId::Boolean) {
      os << " = false";
    } else if (is_integral(token_id)) {
      os << " = 0";
    } else if (is_floating_point(token_id)) {
      os << " = 0.0";
    }
    break;
  }
  default:
    // For structs, enums, etc., make them optional or require init
    os << "?  // TODO: provide default value";
    break;
  }
  
  os << "\n";
}

void SwiftBuilder::emit_struct2(AstStructDecl* s, bool is_exception)
{
  const std::string type_keyword = is_exception ? "struct" : "struct";
  
  out << bl() << "public " << type_keyword << " " << swift_type_name(s->name);
  
  if (is_exception) {
    out << ": NPRPCError";
  } else {
    out << ": Codable, Sendable";
  }
  
  out << " " << bb();
  
  // Emit fields
  for (auto field : s->fields) {
    emit_field(field, out);
  }
  
  // For exceptions, add the required message property
  if (is_exception) {
    out << bl() << "public var message: String { \"" << s->name << "\" }\n";
  }
  
  out << eb() << "\n";
}

void SwiftBuilder::emit_struct(AstStructDecl* s)
{
  emit_struct2(s, false);
}

void SwiftBuilder::emit_exception(AstStructDecl* s)
{
  emit_struct2(s, true);
}

void SwiftBuilder::emit_enum(AstEnumDecl* e)
{
  out << bl() << "public enum " << swift_type_name(e->name) << ": Int " << bb();
  
  // Emit cases
  for (auto& item : e->items) {
    out << bl() << "case " << swift_method_name(item.first);
    if (item.second.second) { // has explicit value
      out << " = " << item.second.first;
    }
    out << "\n";
  }
  
  out << eb() << "\n";
}

void SwiftBuilder::emit_using(AstAliasDecl* u)
{
  out << bl() << "public typealias " << swift_type_name(u->name) << " = ";
  emit_type(u->type, out);
  out << "\n\n";
}

void SwiftBuilder::emit_protocol(AstInterfaceDecl* ifs)
{
  // Generate Swift protocol for the interface
  out << bl() << "public protocol " << swift_type_name(ifs->name) << "Protocol"
      << " " << bb();
  
  // Emit method signatures
  for (auto& fn : ifs->fns) {
    out << bl() << "func " << swift_method_name(fn->name) << "(";
    
    // Parameters
    bool first = true;
    for (auto& arg : fn->args) {
      if (!first)
        out << ", ";
      first = false;
      out << arg->name << ": ";
      emit_type(arg->type, out);
    }
    
    out << ")";
    
    // Return type
    if (!fn->is_void()) {
      out << " async throws -> ";
      emit_type(fn->ret_value, out);
    } else {
      out << " async throws";
    }
    
    out << "\n";
  }
  
  out << eb() << "\n";
}

void SwiftBuilder::emit_client_proxy(AstInterfaceDecl* ifs)
{
  const std::string class_name = swift_type_name(ifs->name);
  
  // TODO: Generate client proxy class that implements the protocol
  // and handles RPC calls via Object/ObjectPtr
  out << bl() << "// Client proxy for " << class_name << "\n";
  out << bl() << "// TODO: Implement client proxy\n\n";
}

void SwiftBuilder::emit_servant_base(AstInterfaceDecl* ifs)
{
  // TODO: Generate servant base class for server-side implementation
  out << bl() << "// Servant base for " << swift_type_name(ifs->name) << "\n";
  out << bl() << "// TODO: Implement servant base\n\n";
}

void SwiftBuilder::emit_interface(AstInterfaceDecl* ifs)
{
  emit_protocol(ifs);
  emit_client_proxy(ifs);
  emit_servant_base(ifs);
}

void SwiftBuilder::emit_marshal_function(AstStructDecl* s)
{
  // TODO: Implement marshalling to flat buffer
}

void SwiftBuilder::emit_unmarshal_function(AstStructDecl* s)
{
  // TODO: Implement unmarshalling from flat buffer
}

void SwiftBuilder::emit_namespace_begin()
{
  auto ns = ctx_->nm_cur();
  if (!ns->name().empty()) {
    out << bl() << "public enum " << ns->name() << " " << bb();
  }
}

void SwiftBuilder::emit_namespace_end()
{
  auto ns = ctx_->nm_cur();
  if (!ns->name().empty()) {
    out << eb() << "\n";
  }
}

void SwiftBuilder::finalize()
{
  if (out.str().empty())
    return;
  
  // Write to output file
  auto output_file = out_dir_ / (ctx_->module() + ".swift");
  
  std::ofstream ofs(output_file);
  if (!ofs) {
    throw std::runtime_error("Failed to open output file: " +
                             output_file.string());
  }
  
  ofs << out.str();
  ofs.close();
  
  std::cout << "Generated: " << output_file << "\n";
}

} // namespace npidl::builders
